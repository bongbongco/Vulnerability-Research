# CVE-2017-11352

[ImageMagick](https://www.imagemagick.org/script/index.php) 에서 발생했던 CVE-2017-9144 취약점의 미흡한 조치로 인하여 동일한 취약점이 다시 발생되었다. 재 발생된 취약점 CVE-2017-11352은 **coders/rle.c** 에서 RLE 이미지에 대한 부적절한 EOF 처리가 원인이었다.

> **EOF 란?**
>  파일의 끝(End of File, EOF)으로 데이터 소스로부터 더 이상 읽을 수 있는 데이터가 없음을 나타낸다.

[ImageMagick Github Page](https://github.com/ImageMagick/ImageMagick/issues/502)에 들어가보면 해당 이슈를 상세히 확인할 수 있다. 부적절한 EOF 처리 원인은 소스 코드 수정 시 유사한 코드를 복사 붙여넣기 하는 과정에서 검증해야할 변수 명을 고치지 않고 그대로 적용해서 발생했다.

```cpp
operand=ReadBlobByte(image);
if (opcode == EOF)
  ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
```

이로 인해서 조치 완료된 줄 알았던 CVE-2017-9144 취약점은 CVE-2017-11352이라는 새로운 취약점 명으로 다시 조치 되었다.

```cpp
   case SkipLinesOp:
          {
            operand=ReadBlobByte(image);
 -          if (opcode == EOF)
 +          if (operand == EOF)
              ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
            if (opcode & 0x40)
              {
                operand=ReadBlobLSBSignedShort(image);
 -              if (opcode == EOF)
 +              if (operand == EOF)
                  ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
 -	    }
 +            }
            x=0;
            y+=operand;
            break;
          }
          case SetColorOp:
          {
            operand=ReadBlobByte(image);
 -          if (opcode == EOF)
 +          if (operand == EOF)
              ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
            plane=(unsigned char) operand;
            if (plane == 255)
 @@ -401,12 +401,12 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
          case SkipPixelsOp:
          {
            operand=ReadBlobByte(image);
 -          if (opcode == EOF)
 +          if (operand == EOF)
              ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
            if (opcode & 0x40)
              {
                operand=ReadBlobLSBSignedShort(image);
 -              if (opcode == EOF)
 +              if (operand == EOF)
                  ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
              }
            x+=operand;
 @@ -415,12 +415,12 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
          case ByteDataOp:
          {
            operand=ReadBlobByte(image);
 -          if (opcode == EOF)
 +          if (operand == EOF)
              ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
            if (opcode & 0x40)
              {
                operand=ReadBlobLSBSignedShort(image);
 -              if (opcode == EOF)
 +              if (operand == EOF)
                  ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
              }
            offset=(ssize_t) (((image->rows-y-1)*image->columns*number_planes)+x*
 @@ -451,12 +451,12 @@ static Image *ReadRLEImage(const ImageInfo *image_info,ExceptionInfo *exception)
          case RunDataOp:
          {
            operand=ReadBlobByte(image);
 -          if (opcode == EOF)
 +          if (operand == EOF)
              ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
            if (opcode & 0x40)
              {
                operand=ReadBlobLSBSignedShort(image);
 -              if (opcode == EOF)
 +              if (operand == EOF)
                  ThrowRLEException(CorruptImageError,"UnexpectedEndOfFile");
              }
            pixel=(unsigned char) ReadBlobByte(image);
```
