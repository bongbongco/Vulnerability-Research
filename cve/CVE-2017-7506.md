# CVE-2017-7506
[Spice](https://www.spice-space.org)는 가상환경용 통신 프로토콜로 가상 머신과 호스트 사용자 간의 완벽한 상호작용을 도와준다. 최근 오버플로우 취약점이 발견되었고 성공적으로 패치가 완료되었다.  
[bugzilla](https://bugzilla.redhat.com/show_bug.cgi?id=1452606)  

취약점 패치되기 전 소스코드를 살펴보면 크기 검증없이 외부 입력 값을 기반으로 메모리를 할당하여 사용하고 있다는 것을 확인할 수 있다. 이로 인해 오버플로우 취약점이 발생되고 realloc 함수에 음수를 전달하여 가상 머신을 중단시키는 것 또한 가능하다.

```cpp
 static void reds_on_main_agent_monitors_config(
         MainChannelClient *mcc, void *message, size_t size)
 {
    VDAgentMessage *msg_header;
    VDAgentMonitorsConfig *monitors_config;
    RedsClientMonitorsConfig *cmc = &reds->client_monitors_config;
 
    cmc->buffer_size += size;
    cmc->buffer = realloc(cmc->buffer, cmc->buffer_size);
    spice_assert(cmc->buffer);
    cmc->mcc = mcc;
    memcpy(cmc->buffer + cmc->buffer_pos, message, size);
    cmc->buffer_pos += size;

    msg_header = (VDAgentMessage *)cmc->buffer;
    if (sizeof(VDAgentMessage) > cmc->buffer_size ||
           msg_header->size > cmc->buffer_size - sizeof(VDAgentMessage)) {
        spice_debug("not enough data yet. %d", cmc->buffer_size);
        return;
    }

    spice_debug("%s: %d", __func__, monitors_config->num_of_monitors);
    red_dispatcher_client_monitors_config(monitors_config);
    reds_client_monitors_config_cleanup();
}
```
  
패치가 적용된 소스 코드를 살펴보면 제한 값을 정의하고 제한 값보다 큰 입력 값 전달 여부를 확인하여 취약점 발생을 방지하고 있다.
```cpp
static void reds_on_main_agent_monitors_config(
         MainChannelClient *mcc, void *message, size_t size)
 {
    const unsigned int MAX_MONITORS = 256;
    const unsigned int MAX_MONITOR_CONFIG_SIZE =
      sizeof(VDAgentMonitorsConfig) + MAX_MONITORS * sizeof(VDAgentMonConfig);

    VDAgentMessage *msg_header;
    VDAgentMonitorsConfig *monitors_config;
    RedsClientMonitorsConfig *cmc = &reds->client_monitors_config;
 
    // limit size of message sent by the client as this can cause a DoS through
    // memory exhaustion, or potentially some integer overflows
    if (sizeof(VDAgentMessage) + MAX_MONITOR_CONFIG_SIZE - cmc->buffer_size < size) {
        goto overflow;
    }
    cmc->buffer_size += size;
    cmc->buffer = realloc(cmc->buffer, cmc->buffer_size);
    spice_assert(cmc->buffer);
    cmc->mcc = mcc;
    memcpy(cmc->buffer + cmc->buffer_pos, message, size);
    cmc->buffer_pos += size;
    if (sizeof(VDAgentMessage) > cmc->buffer_size) {
        spice_debug("not enough data yet. %d", cmc->buffer_size);
        return;
    }
    msg_header = (VDAgentMessage *)cmc->buffer;
    if (msg_header->size > MAX_MONITOR_CONFIG_SIZE) {
       goto overflow;
    }
    if (msg_header->size > cmc->buffer_size - sizeof(VDAgentMessage)) {
        spice_debug("not enough data yet. %d", cmc->buffer_size);
        return;
    }

     spice_debug("%s: %d", __func__, monitors_config->num_of_monitors);
     red_dispatcher_client_monitors_config(monitors_config);
     reds_client_monitors_config_cleanup();
    return;

overflow:
    spice_warning("received invalid MonitorsConfig request from client, disconnecting");
    red_channel_client_disconnect(main_channel_client_get_base(mcc));
    reds_client_monitors_config_cleanup();
}
```