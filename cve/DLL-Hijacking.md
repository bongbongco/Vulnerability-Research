# DLL Hijacking

Windows의 높은 시장 점유율이 완벽한 보안으로 연결되지는 않는다. DLL Hijacking이 그 대표적인 예로 비즈니스 어플리케이션에 많은 영향을 미치고 있다. 

## Windows DLL
DLL(Dynamic-Link Libraries)는 데이터와 실행가능한 코드의 모음이다. 소프트웨어 개발 시 DLL을 이용함으로써 쉬운 소프트웨어 업데이트와 어플리케이션 간의 DLL 파일 코드 공유를 통한 메모리 사용률 감소를 기대할 수 있다. 

## Windows DLL Search Order
프로그래머들은 종종 절대경로를 지정하지 않고 DLL 파일을 사용하며, 이는 DLL Hijacking을 야기시키는 결과를 가져온다. 마이크로 소프트에서는 다음과 같은 과정을 거쳐 DLL 파일을 찾는다.

```flow
appDir=>operation: Directory of the Application
currentDir=>operation: Current Directory
sysDir=>operation: System Directory
16bitSysDir=>operation: 16 bit System Directory
winDir=>operation: Windows Directory
dirPathValue=>operation: Directory in PATH value

appDir->currentDir->16bitSysDir->winDir->dirPathValue
```

## Principles of DLL Hijacking
우리는 Windows가 DLL 파일을 찾는 방식을 통해서 DLL Hijacking을 이해할 수 있다. 예를 들어 어떤 어플리케이션에서 `function.dll`파일이 필요한 데 절대경로가 지정되어 있지 않다면, 악의적인 사용자가 `function.dll`파일이 위치한 경로보다 우선 순위가 높은 곳에 자신의 DLL 파일을 위치시켜 악의적인 코드를 실행시키게 할 수 있다.

## Finding DLL Hijacking Vulnerabilities
DLL Hijacking을 찾는 좋은 방법은 `Process Monitor`를 활용하는 것이다. 프로그램을 실행 시 `Process Monitor`를 이용하여 절대경로를 지정하지 않고 불러오는 DLL 파일이 존재하는 지 확인한다.

- Process Monitor 적용 필터
  - `Operation is QueryOpen` Include
  - `Process Name is [검증 프로그램]` Include
  - `Path contains .dll` Include

만약 검증 프로그램에서 DLL Hijacking 취약점이 존재한다면 다음과 같은 결과를 볼 수 있다. 
Path|Result
----|----
C:\Windows\System32\vuln.dll|NAME NOT FOUND
C:\Windows\System\vuln.dll|NAME NOT FOUND
C:\Windows\vuln.dll|NAME NOT FOUND

`Process Monitor`에서 이러한 결과가 나타나는 경우 대부분이 DLL Hijacking 취약점이 존재한다.

## Finding function names from a DLL
DLL Hijacking을 통하여 위조한 코드를 실행하기 위해서는 먼저 함수 명을 알아야한다. 이는 `DUMPBIN` 프로그램의 *EXPORTS* 옵션을 이용하면 할 수 있다. 다른 방법으로는 디버거를 이용하여 저장된 평문 문자열을 확인하는 것이다. 

## Writing DLL exploits
이제 DLL Hijacking을 활용해보자. DLL에서 코드를 읽을 때 수행하는 절차가 있다.

 - Load DLL
```cpp
DLL_FILE = LoadLibrary("test.dll");
``` 

- `output_text` 함수 실행
```cpp
output_text = (DLLPROC)
GetProcAddress(DLL_FILE, "output_text");
```

- DLL 코드
```cpp
void output_text()
{
	cout << "ALL is going well!\n";
	return;
}
```
`test.dll`파일이 Windows 디렉터리에 위치한다고 가정하고 프로그램에서 `test.dll`의 절대경로를 지정하지 않고 불러와 *output_text* 함수를 사용한다면 다음과 같은 결과를 볼 수 있다.
```bash
All is going well!
```
이제 동일한 함수명을 가진 `test.dll` DLL 파일을 생성해보자.
```cpp
void output_test()
{
	cout << "Something's not right here!\n";
	return;
}
```
만약 생성한 파일을 프로그램과 같은 위치에 저장하고 프로그램을 실행한다면 Windows 디렉터리에 저장된 `test.dll`파일 대신에 새로 생성한 DLL 파일을 불러와 실행하게 된다.

## Attacking a victim remotely
많은 사람들이 원본 DLL 파일을 교체하여 공격하는 취약점으로 DLL Hijacking을 생각하기 쉽다. 하지만 목표하는 대상의 컴퓨터에 DLL 파일을 저장하는 것은 간단한 일이 아니다. 다음은 소셜 엔지니어링을 활용한 두 개의 공격 시나리오이다.

- 공격자는 텍스트 뷰어 프로그램에서 취약점을 찾았다. 공격자는 아카이브 파일에 악의적인 DLL파일과 텍스트 파일을 넣는다. 희생자는 텍스트 파일을 열기 위해 아카이브 파일을 다운로드 받고 압축을 풀게 된다. 아카이브 프로그램은 취약한 텍스트 뷰어의 위치에 압축을 해제한다. 텍스트 뷰어는 공격자의 DLL에서 함수를 읽어 실행하게 된다.
- 공격자는 전자우편 열람 프로그램에서 취약점을 찾았다. 위조한 DLL 파일과 몇 개의 무작위 파일, 전자우편 파일을 회사에서 사용하는 공유폴더에 업로드한다. 희생자가 전자우편을 열람할 때, 전자우편 열람 프로그램은 Windows 디렉터리에 저장된 원본 DLL 파일이 아닌 공격자의 DLL 파일을 불러와 위조된 코드를 실행하게 된다.


## Defending against DLL Hijacking
DLL Hijacking 취약점은 라이브러리 사용 시 전체경로를 기입하는 것만으로도 방지할 수 있다. 대안으로 DLL 파일이 위치한 경로를 우선적으로 탐색하는 방법이 있지만 대응방안으로 충분하지 않다. 또 다른 대안으로는 DLL 파일의 체크썸 해시 값 일치 여부를 검증하는 방법이 있다. 추가적으로 사용자 자신이 직접 보호하는 방법이 있다. 예를 들어 사진을 다운받았을 때, DLL 파일이 함께 있다면 DLL 파일을 제거 후 그림 파일을 열람하는 것이다. 그리고 레지스트리 키를 변경하는 방법이 있다.

- HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SessionManager\CWDIllegalInDllSearch
- HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\binaryname.exe\CWDIllegalInDllSearch
