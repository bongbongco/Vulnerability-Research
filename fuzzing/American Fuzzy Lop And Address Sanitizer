# American Fuzzy Lop And Address Sanitizer

## Address Sanitizer(ASAN)
단지 gcc/clang에 `-fsanitize=address` 옵션을 추가하는 것으로 간단히 사용할 수 있지만 그 효과는 충분하다.

### <i class="icon-pencil"></i> Example
#### <i class="icon-keyboard"></i> Out Of Bounds Read
```c
#include <stdio.h>
int main() {
  int a[2] = {3, 1};
  int i = 2;
  printf("%i\n", a[i]);
}
```
예제 파일을 `OutOfBoundsRead.c`로 생성하고 *ASAN* 옵션을 지정하여 *clang*으로 컴파일하자.
```sh
clang -g -fsanitize=address -fno-omit-frame-pointer OutOfBoundsRead.c -o OutOfBoundsRead
```
생성된 `OutBoundsRead` 파일을 실행하면 다음과 같은 결과를 볼 수 있다.
>=================================================================
>**==3678==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffc0ba87428 at pc 0x47b7db bp 0x7ffc0ba87390 sp 0x7ffc0ba87388**
>**READ of size 4 at 0x7ffc0ba87428 thread T0**
>==3678==WARNING: Trying to symbolize code, but external symbolizer is not initialized!
>    #0 0x47b7da (/root/ASAN/OutOfBoundsRead+0x47b7da)
>    #1 0x7faba0260f44 (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
>    #2 0x47b42c (/root/ASAN/OutOfBoundsRead+0x47b42c)
>
>**Address 0x7ffc0ba87428 is located in stack of thread T0 at offset 40 in frame**
>    #0 0x47b4ff (/root/ASAN/OutOfBoundsRead+0x47b4ff)
>
>  This frame has 2 object(s):
>    [32, 40) 'a' **<== Memory access at offset 40 overflows this variable**
>    [96, 100) 'i'
>HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext
>      (longjmp and C++ exceptions *are* supported)
>SUMMARY: AddressSanitizer: stack-buffer-overflow ??:0 ??
>Shadow bytes around the buggy address:
>  0x100001748e30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748e40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748e50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748e60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748e70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>=>0x100001748e80: f1 f1 f1 f1 00[f4]f4 f4 f2 f2 f2 f2 04 f4 f4 f4
>  0x100001748e90: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748ea0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748eb0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748ec0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>  0x100001748ed0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
>Shadow byte legend (one shadow byte represents 8 application bytes):
>  Addressable:           00
>  Partially addressable: 01 02 03 04 05 06 07 
>  Heap left redzone:     fa
>  Heap right redzone:    fb
>  Freed heap region:     fd
>  Stack left redzone:    f1
>  Stack mid redzone:     f2
>  Stack right redzone:   f3
>  Stack partial redzone: f4
>  Stack after return:    f5
>  Stack use after scope: f8
>  Global redzone:        f9
>  Global init order:     f6
>  Poisoned by user:      f7
>  ASan internal:         fe
>==3678==ABORTING


#### <i class="icon-keyboard"></i> User After Free
```c
#include <stdio.h>
#include <stdlib.h>
int main() {
  char *c = calloc(10, 1);
  printf("%i\n", c[0]);
  free(c);
  printf("%i\n", c[1]);
}
```
예제 파일을 `UserAfterFree.c`로 생성하고  *ASAN* 옵션을 지정하여 *clang*으로 컴파일하자.
```sh
clang -g -fsanitize=address -fno-omit-frame-pointer UserAfterFree.c -o UserAgentFree
```
생성된 UserAgentFree 파일을 실행하면 다음과 같은 결과를 볼 수 있다.
>=================================================================
>==3563==ERROR: AddressSanitizer: **heap-use-after-free on address** 0x60200000eff1 at pc 0x47b57c bp 0x7ffc2a357b60 sp 0x7ffc2a357b58
>READ of size 1 at 0x60200000eff1 thread T0
>==3563==WARNING: Trying to symbolize code, but external symbolizer is not initialized!
>    #0 0x47b57b (/root/ASAN/UserAgentFree+0x47b57b)
>    #1 0x7ff1c77def44 (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)
>    #2 0x47b42c (/root/ASAN/UserAgentFree+0x47b42c)
>
>0x60200000eff1 is located 1 bytes inside of 10-byte region [0x60200000eff0,0x60200000effa)
>freed by thread T0 here:
>    #0 0x4651c9 (/root/ASAN/UserAgentFree+0x4651c9)
>    #1 0x47b535 (/root/ASAN/UserAgentFree+0x47b535)
>   **#2 0x7ff1c77def44 (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)**
>
>previously allocated by thread T0 here:
>    #0 0x465419 (/root/ASAN/UserAgentFree+0x465419)
>    #1 0x47b504 (/root/ASAN/UserAgentFree+0x47b504)
>    **#2 0x7ff1c77def44 (/lib/x86_64-linux-gnu/libc.so.6+0x21f44)**
>
>SUMMARY: AddressSanitizer: heap-use-after-free ??:0 ??
>Shadow bytes around the buggy address:
>  0x0c047fff9da0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9db0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9dc0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9dd0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9de0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>**=>0x0c047fff9df0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[fd]fd**
>  0x0c047fff9e00: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9e10: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9e20: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9e30: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c047fff9e40: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>Shadow byte legend (one shadow byte represents 8 application bytes):
>  Addressable:           00
>  Partially addressable: 01 02 03 04 05 06 07 
>  Heap left redzone:     fa
>  Heap right redzone:    fb
>  Freed heap region:     fd
>  Stack left redzone:    f1
>  Stack mid redzone:     f2
>  Stack right redzone:   f3
>  Stack partial redzone: f4
>  Stack after return:    f5
>  Stack use after scope: f8
>  Global redzone:        f9
>  Global init order:     f6
>  Poisoned by user:      f7
>  ASan internal:         fe
>==3563==ABORTING

[참고 : Clang 6 documentation - AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)

## American Fuzzy Lop
가장 인기있는 퍼징 도구 중 하나로 *American Fuzzy Lop*을 이용하여 발견한 [다양한 취약점](http://lcamtuf.coredump.cx/afl/)들이 존재한다.  *American Fuzzy Lop* 사용 시에 *ASAN*을 설정하면 (`Set AFL_USE_ASAN=1 and add "-m none"`)더 강력한 퍼징을 수행할 수 있다.

*AFL*을 설치 시 포함된 `test-instr.c` 파일을 이용하여 테스트를 진행하자.

### <i class="icon-pencil"></i> Example
#### <i class="icon-keyboard"></i> test-instr.c
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char** argv) {

  char buf[8];

  if (read(0, buf, 8) < 1) {
    printf("Hum?\n");
    exit(1);
  }

  if (buf[0] == '0')
    printf("Looks like a zero to me!\n");
  else
    printf("A non-zero value? How quaint!\n");

  exit(0);

}
```
먼저 *afl-gcc*를 이용하여 컴파일을 한다. (C++인 경우 *afl-g++*를 사용한다.)
```sh
afl-gcc -o test-instr test-instr.c
```

이제 퍼징 테스트를 수행해야 하는 데, 입력 값에 따라 명령어를 다르게 설정해야한다.

- Standard input
```sh
afl-fuzz -i "Testcase 디렉토리" -o "결과를 저장할 디렉토리" "Fuzzing 바이너리" "파라미터"
afl-fuzz -i testcase_dir -o findings_dir /path/to/program [...params...]
```

- File
```sh
afl-fuzz -i "Testcase 디렉토리" -o "결과를 저장할 디렉토리" "Fuzzing 바이너리" @@
afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@
```

테스트에 사용할 *test-instr*의 경우 *Standard input* 형태로 명령어를 구성하면 된다.
```sh
afl-fuzz -i ./testcases/others/text/ -o ./afl-out/ ./test-instr
```

#### <i class="icon-bug"></i> Truble Shooting
>afl-fuzz 2.44b by <lcamtuf@google.com>
>[+] You have 1 CPU core and 6 runnable tasks (utilization: 600%).
>[*] Checking core_pattern...
>
>[-] Hmm, your system is configured to send core dump notifications to >an
>    external utility. This will cause issues: there will be an >extended delay
>    between stumbling upon a crash and having this information >relayed to the
>    fuzzer via the standard waitpid() API.
>
>    To avoid having crashes misinterpreted as timeouts, please log in >as root
>    and temporarily modify /proc/sys/kernel/core_pattern, like so:
>
>    **echo core >/proc/sys/kernel/core_pattern**
>
>[-] PROGRAM ABORT : Pipe at the beginning of 'core_pattern'
>         Location : check_crash_handling(), afl-fuzz.c:7246

위와 같은 에러가 발생 시 에러 구문에서 출력된 명령어를 수행하면 정상적으로 사용이 가능하다.

```sh
echo core >/proc/sys/kernel/core_pattern
```
[참고 : AFL fuzz(american fuzzy lop) Fuzzing Tool 사용하기](http://kaspyx.tistory.com/79)

## LIBFUZZER
[LIBFUZZER](http://llvm.org/docs/LibFuzzer.html)는 매우 유용한 퍼징 도구로 *American Fuzzy Lop*과 함께 활용하면 좋다. *American Fuzzy Lop*와 차이점으로 *American Fuzzy Lop*는 실행 형태인 반면 *LIBFUZZER*는 함수 형태로 퍼징 테스트를 위해서 초기 작업이 필요하다.  `(HeartBleed 취약점을 찾을 때 까지 AFL은 최대 6시간이 소요되지만, LIBFUZZER를 이용하면 5분이면 가능하다.)`

### <i class="icon-desktop"></i> Install 
#### <i class="icon-keyboard"></i> Local & VM
```bash
# git 설치 및 튜토리얼 다운로드
sudo apt-get --yes install git
git clone https://github.com/google/fuzzer-test-suite.git FTS
./FTS/tutorial/install-deps.sh  # Get deps
./FTS/tutorial/install-clang.sh # Get fresh clang binaries
# libFuzzer sources 빌드
svn co https://llvm.org/svn/llvm-project/llvm/trunk/lib/Fuzzer
Fuzzer/build.sh
```

#### <i class="icon-keyboard"></i> Docker
```bash
install docker
docker run --cap-add SYS_PTRACE -ti libfuzzertutorial/base
```

### <i class="icon-pencil"></i> Example
#### <i class="icon-keyboard"></i> fuzz_me.cc
튜토리얼에 포함된 *fuzz_me.cc* 소스코드를 이용하여 *LIBFUZZER* 이용 방법을 살펴보자.
```cpp
#include <stdint.h>
#include <stddef.h>

bool FuzzMe(const uint8_t *Data,
            size_t DataSize) {
  return DataSize >= 3 &&
      Data[0] == 'F' &&
      Data[1] == 'U' &&
      Data[2] == 'Z' &&
      Data[3] == 'Z';  // :‑<
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  FuzzMe(Data, Size);
  return 0;
}

```
*LIBFUZZER*를 이용하여 퍼징 테스트를 진행해보자.
```bash
clang++ -g -fsanitize=address -fsanitize-coverage=trace-pc-guard FTS/tutorial/fuzz_me.cc libFuzzer.a 
./a.out
```
동작에 성공했다면 *a.out* 파일 실행 시 다음과 같은 정보를 출력하는 것을 확인할 수 있다. (*clang++* 옵션에 지정한 *ASAN* 결과도 함께 포함되어 있다.)
>INFO: Seed: 85630000
>INFO: Loaded 1 modules (7 guards): [0x743e10, 0x743e2c), 
>INFO: -max_len is not provided, using 64
>INFO: A corpus is not provided, starting from an empty corpus
>  #0	 READ units: 1
>  #1	 INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 14Mb
>  #3 NEW    cov: 4 ft: 4 corp: 2/6b exec/s: 0 rss: 15Mb L: 5 MS: 2 ChangeBit-CMP- DE: "\x01\x00\x00\x00"-
>  #3736 NEW    cov: 5 ft: 5 corp: 3/34b exec/s: 0 rss: 15Mb L: 28 MS: 5 InsertByte-CopyPart-EraseBytes-EraseBytes-InsertRepeatedBytes-
>  #85472	NEW    cov: 6 ft: 6 corp: 4/62b exec/s: 0 rss: 21Mb L: 28 MS: 1 ChangeByte-
>  #166628	NEW    cov: 7 ft: 7 corp: 5/104b exec/s: 0 rss: 26Mb L: 42 MS: 2 PersAutoDict-InsertRepeatedBytes- DE: "\x01\x00\x00\x00"-
>
>=================================================================
>
>**==116:116==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020001bb8f3 at pc 0x0000004eb623 bp 0x7ffcafdae280 sp 0x7ffcafdae278**
>**READ of size 1 at 0x6020001bb8f3 thread T0**
>    #0 0x4eb622 in FuzzMe(unsigned char const*, unsigned long) /root/FTS/tutorial/fuzz_me.cc:10:7
>    #1 0x4eb68e in LLVMFuzzerTestOneInput /root/FTS/tutorial/fuzz_me.cc:14:3
>    #2 0x4f4d83 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /root/Fuzzer/FuzzerLoop.cpp:493:13
>    #3 0x4f4fb0 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /root/Fuzzer/FuzzerLoop.cpp:450:3
>    #4 0x4f631b in fuzzer::Fuzzer::MutateAndTestOne() /root/Fuzzer/FuzzerLoop.cpp:700:30
>    #5 0x4f6587 in fuzzer::Fuzzer::Loop() /root/Fuzzer/FuzzerLoop.cpp:732:5
>    #6 0x4edba8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /root/Fuzzer/FuzzerDriver.cpp:567:6
>    #7 0x4eb700 in main /root/Fuzzer/FuzzerMain.cpp:20:10
>    #8 0x7f6049f7982f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)
>    #9 0x41c5e8 in _start (/root/a.out+0x41c5e8)
>
>**0x6020001bb8f3 is located 0 bytes to the right of 3-byte region [0x6020001bb8f0,0x6020001bb8f3)**
>**allocated by thread T0 here:**
>    #0 0x4e8752 in operator new[](unsigned long) (/root/a.out+0x4e8752)
>    #1 0x4f4cc9 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) /root/Fuzzer/FuzzerLoop.cpp:484:23
>    #2 0x4f4fb0 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long) /root/Fuzzer/FuzzerLoop.cpp:450:3
>    #3 0x4f631b in fuzzer::Fuzzer::MutateAndTestOne() /root/Fuzzer/FuzzerLoop.cpp:700:30
>    #4 0x4f6587 in fuzzer::Fuzzer::Loop() /root/Fuzzer/FuzzerLoop.cpp:732:5
>    #5 0x4edba8 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) /root/Fuzzer/FuzzerDriver.cpp:567:6
>    #6 0x4eb700 in main /root/Fuzzer/FuzzerMain.cpp:20:10
>    #7 0x7f6049f7982f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)
>
>SUMMARY: AddressSanitizer: heap-buffer-overflow /root/FTS/tutorial/fuzz_me.cc:10:7 in FuzzMe(unsigned char const*, unsigned long)
>Shadow bytes around the buggy address:
>  0x0c048002f6c0: fa fa fd fd fa fa fd fd fa fa fd fa fa fa fd fa
>  0x0c048002f6d0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
>  0x0c048002f6e0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
>  0x0c048002f6f0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
>  0x0c048002f700: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa
>=>0x0c048002f710: fa fa fd fa fa fa fd fa fa fa fd fa fa fa[03]fa
>  0x0c048002f720: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c048002f730: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c048002f740: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c048002f750: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>  0x0c048002f760: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
>Shadow byte legend (one shadow byte represents 8 application bytes):
>  Addressable:           00
>  Partially addressable: 01 02 03 04 05 06 07 
>  Heap left redzone:       fa
>  Freed heap region:       fd
>  Stack left redzone:      f1
>  Stack mid redzone:       f2
>  Stack right redzone:     f3
>  Stack after return:      f5
>  Stack use after scope:   f8
>  Global redzone:          f9
>  Global init order:       f6
>  Poisoned by user:        f7
>  Container overflow:      fc
>  Array cookie:            ac
>  Intra object redzone:    bb
>  ASan internal:           fe
>  Left alloca redzone:     ca
>  Right alloca redzone:    cb
>==116:116==ABORTING
>MS: 4 EraseBytes-InsertByte-ChangeBinInt-CrossOver-; base unit: 3a54258a942e4f29a7d84ceb41471a56cc36609a
>0x46,0x55,0x5a,
>FUZ
>artifact_prefix='./'; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60
>Base64: RlVa

## Other Sanitizers
- UBSAN (Undefined Behavior Sanitizer) : 쉽게 사용 가능하지만, 찾아내는 취약점의 대부분이 유효하지 않다.
- MSAN (Memory Sanitizer) : 초기화되지 않은 메모리를 찾는 데 사용한다.
- TSAN (Thread Sanitizer) : C++로 개발된 큰 프로젝트에서 사용한다.


