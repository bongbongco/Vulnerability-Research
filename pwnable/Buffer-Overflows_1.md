# Buffer-Overflows_1

버퍼 오버플로우 취약점은 힙 기반과 스택 기반 두 가지 종류로 분류한다. **힙 기반 오버플로우**는 동적으로 메모리를 할당할 때 메모리 영역에 과도한 값을 채워 넣어 유발시키며 보통 프로그래머의 계산 실수로 발생된다. **스택 기반 오버플로우**는 정적인 크기의 로컬 버퍼에서 저장하도록 의도된 것에 비해 많은 데이터를 의도적으로 삽입하여 발생시킨다.

## <i class="icon-pencil"></i> Stack Based
다음은 스택 기반 오버플로우의 예시로 일반적으로 사용되는 IMAP 서버의 cyrus-imapd에서 발생된 오버플로우이다.
>**IMAP(Ineternet Message Access Protocol)**
>응용 계층 인터넷 프로토콜 중 하나로, 원격 서버로부터 TCP/IP 연결을 통해 이메일을 가져오는데 사용된다.
>출처: [위키피디아](https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%EB%A9%94%EC%8B%9C%EC%A7%80_%EC%A0%91%EC%86%8D_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)
>
>**Cyrus IMAP Server**
>Cyrus IMAP Server는 카네기 멜론 대학교에서 개발한 이메일 서버 소프트웨어이다.

```c
static int popd_canon_user(sasl_conn_t *conn, void *context,
               const char *user, unsigned ulen,
               unsigned flags, const char *user_realm,
               char *out, unsigned out_max, unsigned *out_ulen)
{
    char userbuf[MAX_MAILBOX_NAME+1], *p;
    size_t n;
    int r;
    if (!ulen) ulen = strlen(user);
    if (config_getswitch(IMAPOPT_POPSUBFOLDERS)) {  
     //if popsubfolders  
     //configed
    /* make a working copy of the auth[z]id */
    memcpy(userbuf, user, ulen); //사용자 변수 검증 없음
    userbuf[ulen] = '';
    user = userbuf;
... 
} 
```
- 스택 위의 `userbuf`변수는 정적인 크기*(MAX_MAILBOX_NAME + 1)*로 할당되어 있다. 
- `ulen`변수는 사용자 인자 값의 문자열 길이를 저장한다. 
- *memcpy*함수를 이용하여 메모리 영역 복사 전 인자 값으로 전달 받은 복사 바이트 수에 대한 검증이 없다.
- *"if"*문을 이용하여 *popsubfolder*설정을 확인하는 과정이 있기 때문에 *popsubfolder* 설정이 되어 있지 않다면 공격 벡터에 도달할 수 없다.

*memcpy*함수는 `ulen`변수를 이용하여 `userbuf`에서 몇 바이트를 복사할지 결정하는 데, `ulen`이 `userbuf`에게 지정된 크기 *MAX_MAILBOX_NAME + 1*보다 큰지 검증하는 로직이 존재하지 않아 *MAX_MAILBOX_NAME + 1*보다 큰 유저 명을 `popd_canon_user`함수로 전달하면 오버플로우 취약점이 발생된다. 

## <i class="icon-pencil"></i> Heap Based
다음은 힙 기반 오버플로우의 예시로 유닉스/리눅스 용 미디어 플레이어인 MPlay에서 발생된 오버플로우이다.
```c
ibmpdemux/http.c:http_build_request (line 178):  
   if( http_hdr->uri==NULL ) http_set_uri( http_hdr, "/");  
   else {  
      uri = (char*)malloc(strlen(http_hdr->uri)*2);  
      if( uri==NULL ) {  
         mp_msg(MSGT_NETWORK,MSGL_ERR,"Memory allocation failed\n");  
         return NULL;  
     }  
     url_escape_string( uri, http_hdr->uri );  
```
먼저 코드 목적에 대한 이해가 필요하다. 이 코드는 공간에 문자열을 할당한 후, 해당 문자열에서 특정 문자를 이스케이프하거나 변경하려 한다.
>**이스케이프**
>해당 프로그래밍 언어에서 가지는 문자에 대한 특별한 의미에서 벗어나서 해석하게 하는 것

*malloc*함수 호출 시 곱셈을 사용하는 것을 볼 수 있는 데, 이는 이스케이프 문자의 삽입을 고려한 조치임을 예상할 수 있다. 하지만 이러한 계산 방법은 URL 인코딩 문자열에 대한 고려가 없으므로 취약점이 발생하게 된다. 예를 들어 `A`를 표현한다면 `%41`로 인코딩될 것이다. (이와 같이 URL 인코딩 문자열은 세문자를 이용하여 한문자를 나타내게 된다.) 그러므로 `url_escape_string`함수의 결과 코드를 적재하기에 공간이 부족하게 되어 할당된 공간을 벗어나 버퍼 오버플로우가 발생한다.

이밖에도 좀 더 세분화하여 `Off-by-one buffer overflow`, `Adjacent memory overflows`, `Miss matches size caculations` 등으로 버퍼 오버플로우를 분류할 수 있다. 해당 내용은 다음 글에서 이어가도록 하자.
