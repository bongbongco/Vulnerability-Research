from winappdbg import System, Process, HexDump, win32
import sys
import pprint


def print_threads_and_modules(pid):

    process = Process(pid)
    print "Process %d" % process.get_pid()

    print "Threads:"
    for thread in process.iter_threads():
        print "\t %d" % thread.get_tid()

    print "Modules:"
    bits = process.get_bits()
    for module in process.iter_modules():
        print "\t%s\t%s" % (
                HexDump.address(module.get_base(), bits),
                module.get_filename()
                )

def starting_process(path):
    system = System()
    process = system.start_process(path)
    print "Started process %d (%d bits)" % (process.get_pid(), process.get_bits())
    return process.get_pid()

def stoping_process(pid):
    process = Process(pid)
    process.kill()
    print "Kill process"

def process_read(pid):#, address, length):
    process = Process(pid)
    data = process.read(address, length)
    return data

def show_command_line(pid):
    process = Process(pid)
    print process.get_command_line()

def show_environment(pid):
    process = Process(pid)
    environment = process.get_environment()
    for variable, value in sorted(environment.items()):
        print "%s=%s" % (variable, value)

def print_memory_map(pid):
    process = Process(pid)
    bits = process.get_bits()
    memoryMap = process.get_memory_map()
    #print CrashDump.dump_memory_dump(memoryMap)
    
    print "Address  \tSize  \tState \tAccess    \Type"
    for mbi in memoryMap:
        # Address and size of memory block
        BaseAddress = HexDump.address(mbi.BaseAddress, bits)
        RegionSize = HexDump.address(mbi.RegionSize, bits)

        if mbi.State == win32.MEM_RESERVE:
            State = "Reserved   "
        elif mbi.State == win32.MEM_COMMIT:
            State = "commited   "
        elif mbi.State == win32.MEM_FREE:
            State = "Free   "
        else:
            State = "Unknown    "

        if mbi.State != win32.MEM_COMMIT:
            Protect = "          "
        else:
        ## Protect = "0x%.08x" % mbi.Protect
            if mbi.Protect & win32.PAGE_NOACCESS:
                Protect = "--- "
            elif mbi.Protect & win32.PAGE_READONLY:
                Protect = "R-- "
            elif mbi.Protect & win32.PAGE_READWRITE:
                Protect = "RW- "
            elif mbi.Protect & win32.PAGE_WRITECOPY:
                Protect = "RC- "
            elif mbi.Protect & win32.PAGE_EXECUTE:
                Protect = "--X "
            elif mbi.Protect & win32.PAGE_EXECUTE_READ:
                Protect = "R-X "
            elif mbi.Protect & win32.PAGE_EXECUTE_READWRITE:
                Protect = "RWX "
            elif mbi.Protect & win32.PAGE_EXECUTE_WRITECOPY:
                Protect = "RCX "
            else:
                Protect = "??? "
            if mbi.Protect & win32.PAGE_GUARD:
                Protect += "G"
            else:
                Protect += "-"
            if mbi.Protect & win32.PAGE_NOCACHE:
                Protect += "N"
            else:
                Protect += "-"
            if mbi.Protect & win32.PAGE_WRITECOMBINE:
                Protect += "W"
            else:
                Protect += "-"
            Protect += "   "
       
        # Type (file mapping, executable image, or private memory).
        if mbi.Type == win32.MEM_IMAGE:
            Type    = "Image     "
        elif mbi.Type == win32.MEM_MAPPED:
            Type    = "Mapped    "
        elif mbi.Type == win32.MEM_PRIVATE:
            Type    = "Private   "
        elif mbi.Type == 0:
            Type    = "Free      "
        else:
            Type    = "Unknown   "
        
        # Print the memory block information.
        fmt = "%s\t%s\t%s\t%s\t%s"
        print fmt % ( BaseAddress, RegionSize, State, Protect, Type )

def load_dll(pid, filename):
    process = Process(pid)
    process.inject_dll(filename)

def memory_search(pid, bytes):
    process = Process(pid)
    for address in process.search_bytes(bytes):#process.search_text, process.search_hexa
        print HexDump.address(address)

def strings(pid):
    process = Process(pid)
    for address, size, data in process.strings():
        print "%s: %s" % (HexDump.address(address), data)

def freeze_threads(pid):
    System.request_debug_privileges()

    process = Process(pid)
    #process.suspend()
    process.scan_threads()
    for thread in process.iter_threads():
        thread.suspend()

def unfreeze_threads(pid):
    System.request_debug_privileges()
    
    process = Process(pid)
    #process.resume()
    process.scan_threads()
    for thread in process.iter_threads():
        thread.resume()


if __name__ =="__main__":
    #system = System()
    #pid = system.argv_to_cmdline(sys.argv[1:])
    #print_threads_and_modules(int(pid))

    path = "C:\\Program Files (x86)\\GRETECH\\GOMAudio\\Goma.exe"
    pid = starting_process(path)
    print_threads_and_modules(pid)
    #process_read(pid) 
    show_command_line(pid)
    #stoping_process(pid)
    show_environment(pid)
    #print_memory_map(pid)
    #strings(pid)
    freeze_threads(pid)
    unfreeze_threads(pid)
