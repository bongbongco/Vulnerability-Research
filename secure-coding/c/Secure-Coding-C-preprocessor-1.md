# C 언어 시큐어코딩 - Preprocessor 1

## Universal character name을 연결을 통해서 생성하지 않는다.

C 에서는 식별자, 문자 상수 및 문자열 리터럴에서 기본 문자 집합에 없는 universal character names의 사용을 지원한다. Universal character name `\Unnnnnnnn`은 8 자리의 문자 `nnnnnnnn`로 나타낸다. 유사하게 `\Unnnn` universal character name은 `nnnn`(`0000nnnn`)으로 나타낸다.

> 리터럴
> 값 그 자체로, 고정된 값을 의미한다. 예를 들어 `const int b = 8;`에서 b는 상수이고 8은 리터럴이다.

[The C Standard, 5.1.1.2, paragraph 4](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf)에 따르면 **토큰 연결을 통해 생성한 universal character name의 동작은 정의되지 않는 것**으로 서술되어 있다.

이에 반드시 필요한 경우를 제외하고는 universal character names를 통한 식별자 정의를 피한다.

### 잘못된 코드 예제
```c
#define assign(uc1, uc2, val) uc1##uc2 = val

void func(void) {
    int \u0401;
    /*...*/
    assign(\u04, 01, 4);
    /*...*/
}
```

#### 상세 정보
이 코드는 Microsoft Visual Studio 2013을 사용하여 컴파일 및 실행되며 예상대로 변수에 4가 할당된다. 
 Linux에서 GCC 4.8.1은 이 코드를 컴파일하는 것을 거부한다. universal character를 참조하는 assign 매크로에서 '프로그램 이탈'을 반환한다.

### 올바른 코드 예제

Universal character name를 사용하지만 토큰 연결을 사용하여 universal charater name를 생성하지 않는다.
```c
#define assign(ucn, val) ucn = val
  
void func(void) {
    int \u0401;
    /* ... */
    assign(\u0401, 4);
    /* ... */
}
```

> 출처
> [SEI External Wiki - Secure Coding Strandard]Co(https://wiki.sei.cmu.edu/confluence/display/c/PRE30-C.+Do+not+create+a+universal+character+name+through+concatenation)
