#type safety 란 무엇인가.

##Basic Type Safety
"잘 형식화된 프로그램은 잘못될 수 없다." 이 구문은 Robin Milner이 1978년 작성한 `A Theory of Type Polymorphism in Programming`에서 언급된 말로 Type Safety를 직관적으로 보여줍니다.

###Going wrong
프로그래밍 언어는 구문과 의미에 따라 정의된다. 모든 언어가 직면한 문제는 구문적으로 유효하지만 의미상으로 문제가되는 프로그램이 많다는 것이다. 영어를 예로 들자면 Chomsky의 "Colorless green ideals sleep furiously"를 볼 수 있는 데, 구문은 완벽하지만 의미가 없다. 다른 예로 OCaml 프로그래밍 언어의 `1 + "foo";`와 같은 구문은 프로그램에서 어떠한 의미도 없다. C언어에서 `{ char buf[4]; buf[4] = 'x' }`는 인덱스 4에 대한 버퍼 영역을 벗어나고 있으며, 언어적으로 이에 대한 조치가 정의되어 있지 않으므로 의미가 없다고 말할 수 있다. 이러한 무의미한 프로그램을 운영하다면 **go wrong**이라 말할 수 있다.

###Well typed -> Cannot go wrong
type-safe language에서 타입 시스템은 올바른 프로그램만 통과시킨다. 특히 우리는 프로그램이 타입 시스템이 허용한 좋은 형식의 프로그램은 type safety를 보장하고 프로그램의 의미가 잘못되지 않을 것이라 생각한다.

###Which languages are type safe?
이제 인기 좋은 몇몇 언어들이  타입 안전성이 보장되는 언어인지 아닌지 살펴보겠다. 우리는 각기 다른 언어에서 다양한 의미로 적용되고 있는 타입 안전성을 알 수 있다.

####C와 C++: not type safe.
C의 표준 타입 시스템은 버퍼의 끝을 쓰는 것과 같이 일반적 관행을 벗어나는 프로그램을 배제하지 않는다. 따라서 작성된 C 프로그램이 잘못될 수 있다. C++는 C의 상위 집합이므로 C의 타입 안전성을 상속한다.
####Java와 C#: type safe(아마도)
C에서는 제공되지 않았던 동작에 대한 의미를 정의하여 제공한다. 특히, 배열의 범위를 벗어난 엑세스에 대해서 C에서는 의미가 없었지만 Java와 C#에서는 ArrayBoundsException을 throw한다.
####Python, Ruby: type safe(틀림없이)
Python이나 Ruby는 동적 유형의 언어로 불려지며 실행 중에 발생하는 타입 에러에 대한 exception을 throw한다. 런타임 시 배열 오버플로에 대해 Java가 ArrayBoundsException을 throw하는 것처럼 정수나 문자열을 추가하려고 하면 Ruby에서 Exception이 발생한다.

결론이 이상하게 보일 수 있다. Java에서 `o.m()`이 좋은 타입으로 간주되면 타입 안전성은 o가 인수 없는 메소드 m을 갖는 오브젝트임을 보장하므로 호출은 항상 성공한다. Ruby에서 동일한 프로그램 o.m()은 (null)타입 시스템에 의해 항상 잘 입력된 것으로 간주되지만, 실행할 때 o가 메소드 m을 정의한다는 보장이 없으므로 호출이 성공하거나 예외가 발생한다.

정리하면 타입 안전성은 한 가지를 의미하지 않고 암시적으로 잘못된 행동을 정의하는 언어 의미 부여 방식에 달려있다. 

####기초를 넘어서
Generic 타입 안전성은 유용하다. 프로그램이 제대로 정의되었는 지 보장하지 않고 허용할 경우 stack smashing이나 format string attack 과 같은 공격에 당할 위험이 있다. 그러나 단순히 타입 안전성을 보장해주는 지에 대한 여부만 확인하지 말고 언어 별로 제공되는 다른 타입 안전성에 대한 이해를 바탕으로 어떤 시스템을 구성할 수 있을 지 자신에게 물어야 한다.

####격차 좁히기
잘 정의된 프로그램이라도 타입 시스템이 거부하는 경우가 있다. 다음의 경우 대부분의 타입 시스템에서 거부한다.
```c
if (p) x = 5;
  else x = "hello";
if (p) return x+5;
  else return strlen(x);
```
이 프로그램은 항상 정수를 리턴할 것이다. 하지만 타입 시스템은 변수 `x`가 정수와 문자열 양쪽을 사용하므로 거부한다. 이와 같이 타입 시스템은 불완전하고 이는 프로그래머를 힘들게 한다. (아마도 이것이 Python이나 Ruby와 같은 동적 언어를 시작하게 되는 이유일 수 있다.) 한 가지 해결책은 더 많은 프로그램을 수용하면서 격차를 좁힐 수 있게 타입 시스템을 설계하는 것이다.

예를 들어 Java의 타입 시스템은 generics라는 개념으로 버전 1.5로 확장되었다. 1.4에서는 프로그램을 받아들이기 위해 cast를 사용해야 할 수도 있었지만, 1.5에서는 cast가 필요하지 않을 수 있게 되었다.
